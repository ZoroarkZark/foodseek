{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = backwardsCompatibleAnimWrapper;\n\nvar _base = require(\"../base\");\n\nvar _AnimatedClock = _interopRequireDefault(require(\"../core/AnimatedClock\"));\n\nvar _evaluateOnce = require(\"../derived/evaluateOnce\");\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  var newClock = new _AnimatedClock.default();\n  var currentState = animationStateDefaults();\n  var alwaysNode;\n  var isStarted = false;\n  var isDone = false;\n  var wasStopped = false;\n  var animationCallback;\n  var animation = {\n    start: function start(currentAnimationCallback) {\n      animationCallback = currentAnimationCallback;\n\n      if (isStarted) {\n        animationCallback && animationCallback({\n          finished: false\n        });\n        return;\n      }\n\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      (0, _evaluateOnce.evaluateOnce)((0, _base.set)(currentState.position, value), currentState.position, function () {\n        alwaysNode = (0, _base.always)((0, _base.set)(value, (0, _base.block)([(0, _base.cond)((0, _base.clockRunning)(newClock), 0, (0, _base.startClock)(newClock)), node(newClock, currentState, config), (0, _base.cond)(currentState.finished, [(0, _base.call)([], function () {\n          isStarted = false;\n\n          if (!wasStopped) {\n            isDone = true;\n          }\n\n          value.__detachAnimation(animation);\n\n          isDone = true;\n\n          if (!wasStopped) {\n            wasStopped = false;\n          }\n        }), (0, _base.stopClock)(newClock)]), currentState.position])));\n\n        value.__attachAnimation(animation);\n\n        alwaysNode.__addChild(value);\n      });\n    },\n    __detach: function __detach() {\n      animationCallback && animationCallback({\n        finished: isDone\n      });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: function stop() {\n      if (isDone) {\n        console.warn('Calling stop has no effect as the animation has already completed');\n        return;\n      }\n\n      if (!isStarted) {\n        console.warn(\"Calling stop has no effect as the animation hasn't been started\");\n        return;\n      }\n\n      wasStopped = true;\n      (0, _evaluateOnce.evaluateOnce)((0, _base.set)(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: function __stopImmediately_testOnly(result) {\n      animation.stop();\n      isDone = result;\n\n      value.__detachAnimation(animation);\n    }\n  };\n  return animation;\n}\n\nfunction backwardsCompatibleAnimWrapper(node, animationStateDefaults) {\n  return function (clock, state, config) {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}","map":{"version":3,"sources":["C:/Users/Mr. REEETARD/Desktop/FoodSeek/foodseek/src/ui/foodseek/node_modules/react-native-reanimated/lib/reanimated1/animations/backwardCompatibleAnimWrapper.js"],"names":["createOldAnimationObject","node","animationStateDefaults","value","config","newClock","Clock","currentState","alwaysNode","isStarted","isDone","wasStopped","animationCallback","animation","start","currentAnimationCallback","finished","console","warn","isNativelyInitialized","position","__detachAnimation","__attachAnimation","__addChild","__detach","__initialized","__removeChild","stop","__stopImmediately_testOnly","result","backwardsCompatibleAnimWrapper","clock","state","undefined"],"mappings":"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","sourcesContent":["import {\r\n  always,\r\n  block,\r\n  call,\r\n  clockRunning,\r\n  cond,\r\n  set,\r\n  startClock,\r\n  stopClock,\r\n} from '../base';\r\nimport Clock from '../core/AnimatedClock';\r\nimport { evaluateOnce } from '../derived/evaluateOnce';\r\n\r\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\r\n  const newClock = new Clock();\r\n  const currentState = animationStateDefaults();\r\n  let alwaysNode;\r\n  let isStarted = false;\r\n  let isDone = false;\r\n  let wasStopped = false;\r\n  let animationCallback;\r\n  const animation = {\r\n    start: (currentAnimationCallback) => {\r\n      animationCallback = currentAnimationCallback;\r\n      if (isStarted) {\r\n        animationCallback && animationCallback({ finished: false });\r\n        return;\r\n      }\r\n      if (isDone) {\r\n        console.warn('Animation has been finished before');\r\n        // inconsistent with React Native\r\n        return;\r\n      }\r\n\r\n      if (!value.isNativelyInitialized()) {\r\n        return;\r\n      }\r\n\r\n      isStarted = true;\r\n      evaluateOnce(\r\n        set(currentState.position, value),\r\n        currentState.position,\r\n        () => {\r\n          alwaysNode = always(\r\n            set(\r\n              value,\r\n              block([\r\n                cond(clockRunning(newClock), 0, startClock(newClock)),\r\n                node(newClock, currentState, config),\r\n                cond(currentState.finished, [\r\n                  call([], () => {\r\n                    isStarted = false;\r\n                    if (!wasStopped) {\r\n                      isDone = true;\r\n                    }\r\n                    value.__detachAnimation(animation);\r\n                    isDone = true;\r\n                    if (!wasStopped) {\r\n                      wasStopped = false;\r\n                    }\r\n                  }),\r\n                  stopClock(newClock),\r\n                ]),\r\n                currentState.position,\r\n              ])\r\n            )\r\n          );\r\n          value.__attachAnimation(animation);\r\n          alwaysNode.__addChild(value);\r\n        }\r\n      );\r\n    },\r\n    __detach: () => {\r\n      animationCallback && animationCallback({ finished: isDone });\r\n      animationCallback = null;\r\n      value.__initialized && alwaysNode.__removeChild(value);\r\n    },\r\n    stop: () => {\r\n      if (isDone) {\r\n        console.warn(\r\n          'Calling stop has no effect as the animation has already completed'\r\n        );\r\n        return;\r\n      }\r\n      if (!isStarted) {\r\n        console.warn(\r\n          \"Calling stop has no effect as the animation hasn't been started\"\r\n        );\r\n        return;\r\n      }\r\n      wasStopped = true;\r\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\r\n    },\r\n    __stopImmediately_testOnly: (result) => {\r\n      animation.stop();\r\n      isDone = result;\r\n      value.__detachAnimation(animation);\r\n    },\r\n  };\r\n  return animation;\r\n}\r\n\r\n/**\r\n * Depending on the arguments list we either return animation node or return an\r\n * animation object that is compatible with the original Animated API\r\n */\r\nexport default function backwardsCompatibleAnimWrapper(\r\n  node,\r\n  animationStateDefaults\r\n) {\r\n  return (clock, state, config) => {\r\n    if (config !== undefined) {\r\n      return node(clock, state, config);\r\n    }\r\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"script"}